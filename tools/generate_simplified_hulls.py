#!/usr/bin/env python3
"""
Script per generare convex hull semplificati dalle mesh originali.

Usa scipy.spatial.ConvexHull per creare hull con pochi vertici (~20-50) 
che catturano la forma essenziale per la collision detection.
"""

import numpy as np
from scipy.spatial import ConvexHull
from pathlib import Path
import sys


def load_obj_vertices(obj_path: str) -> np.ndarray:
    """Carica i vertici da un file OBJ."""
    vertices = []
    with open(obj_path, 'r') as f:
        for line in f:
            if line.startswith('v '):
                parts = line.strip().split()
                if len(parts) >= 4:
                    x, y, z = float(parts[1]), float(parts[2]), float(parts[3])
                    vertices.append([x, y, z])
    return np.array(vertices)


def save_obj(vertices: np.ndarray, faces: list, obj_path: str):
    """Salva un convex hull come file OBJ."""
    with open(obj_path, 'w') as f:
        f.write(f"# Simplified convex hull with {len(vertices)} vertices\n")
        f.write(f"# Generated by generate_simplified_hulls.py\n\n")
        
        # Scrivi i vertici
        for v in vertices:
            f.write(f"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f}\n")
        
        f.write("\n")
        
        # Scrivi le facce (indici 1-based per OBJ)
        for face in faces:
            face_str = " ".join(str(i + 1) for i in face)
            f.write(f"f {face_str}\n")


def simplify_hull(vertices: np.ndarray, target_vertices: int = 50) -> tuple:
    """
    Crea un convex hull semplificato con un numero target di vertici.
    
    Args:
        vertices: Nuvola di punti originale
        target_vertices: Numero desiderato di vertici nell'hull semplificato
    
    Returns:
        Tuple (simplified_vertices, faces)
    """
    # Prima, calcola il convex hull completo
    hull = ConvexHull(vertices)
    hull_vertices = vertices[hull.vertices]
    
    print(f"  Hull originale: {len(hull_vertices)} vertici")
    
    if len(hull_vertices) <= target_vertices:
        # Hull già abbastanza piccolo
        hull_faces = []
        # Ricostruisci le facce con gli indici corretti
        vertex_map = {old: new for new, old in enumerate(hull.vertices)}
        for simplex in hull.simplices:
            face = [vertex_map[idx] for idx in simplex]
            hull_faces.append(face)
        return hull_vertices, hull_faces
    
    # Semplifica usando clustering k-means sui vertici dell'hull
    from scipy.cluster.vq import kmeans2
    
    # Cluster i vertici dell'hull
    centroids, labels = kmeans2(hull_vertices, target_vertices, minit='points')
    
    # Per ogni cluster, prendi il punto più esterno (più lontano dal centro)
    center = hull_vertices.mean(axis=0)
    simplified_vertices = []
    
    for i in range(target_vertices):
        cluster_points = hull_vertices[labels == i]
        if len(cluster_points) == 0:
            continue
        # Prendi il punto più lontano dal centro
        distances = np.linalg.norm(cluster_points - center, axis=1)
        furthest_idx = np.argmax(distances)
        simplified_vertices.append(cluster_points[furthest_idx])
    
    simplified_vertices = np.array(simplified_vertices)
    
    # Ricalcola l'hull sui vertici semplificati
    try:
        simplified_hull = ConvexHull(simplified_vertices)
        final_vertices = simplified_vertices[simplified_hull.vertices]
        
        # Ricostruisci le facce
        vertex_map = {old: new for new, old in enumerate(simplified_hull.vertices)}
        final_faces = []
        for simplex in simplified_hull.simplices:
            face = [vertex_map[idx] for idx in simplex]
            final_faces.append(face)
        
        return final_vertices, final_faces
    except Exception as e:
        print(f"  Warning: Errore nel ricalcolo hull, uso vertici cluster: {e}")
        # Fallback: usa direttamente i centroidi
        try:
            fallback_hull = ConvexHull(centroids)
            final_vertices = centroids[fallback_hull.vertices]
            vertex_map = {old: new for new, old in enumerate(fallback_hull.vertices)}
            final_faces = []
            for simplex in fallback_hull.simplices:
                face = [vertex_map[idx] for idx in simplex]
                final_faces.append(face)
            return final_vertices, final_faces
        except:
            # Ultimo fallback: usa tutti i centroidi
            fallback_hull = ConvexHull(centroids)
            return centroids, [[i for i in simplex] for simplex in fallback_hull.simplices]


def main():
    # Percorso delle mesh originali
    hulls_dir = Path(__file__).parent.parent / "graphics" / "hulls"
    
    if not hulls_dir.exists():
        print(f"Errore: directory {hulls_dir} non trovata")
        sys.exit(1)
    
    # File da processare
    files_to_process = [
        ("core_battery_transformed_hull.obj", "core_battery_simplified_hull.obj", 40),
        ("arm_transformed_hull.obj", "arm_simplified_hull.obj", 30),
    ]
    
    print("=" * 60)
    print("Generazione Convex Hull Semplificati")
    print("=" * 60)
    
    for input_name, output_name, target_verts in files_to_process:
        input_path = hulls_dir / input_name
        output_path = hulls_dir / output_name
        
        if not input_path.exists():
            print(f"\nWarning: {input_path} non trovato, skip")
            continue
        
        print(f"\nProcessando: {input_name}")
        
        # Carica vertici originali
        vertices = load_obj_vertices(str(input_path))
        print(f"  Vertici mesh originale: {len(vertices)}")
        
        # Crea hull semplificato
        simplified_verts, faces = simplify_hull(vertices, target_verts)
        print(f"  Vertici hull semplificato: {len(simplified_verts)}")
        print(f"  Facce: {len(faces)}")
        
        # Salva
        save_obj(simplified_verts, faces, str(output_path))
        print(f"  Salvato: {output_path}")
    
    print("\n" + "=" * 60)
    print("Fatto! Hull semplificati generati in graphics/hulls/")
    print("=" * 60)


if __name__ == "__main__":
    main()
